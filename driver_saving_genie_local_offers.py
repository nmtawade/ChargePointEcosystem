# -*- coding: utf-8 -*-
"""Driver saving Genie local offers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RTChNmAl8YkhkW3l0bCzQMYduCe-pW1T
V3
"""

import os
from flask import Flask, request, jsonify
import firebase_admin
from firebase_admin import credentials, messaging
import requests
import logging
from flask_cors import CORS
from google.cloud import secretmanager
import json

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes or configure as needed

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def access_secret_version(secret_id, project_id, version="latest"):
    """
    Accesses the payload for the given secret version if one exists.
    """
    client = secretmanager.SecretManagerServiceClient()
    name = f"projects/{project_id}/secrets/{secret_id}/versions/{version}"
    response = client.access_secret_version(request={"name": name})
    return response.payload.data.decode('UTF-8')

# Retrieve project ID from environment variable
PROJECT_ID = os.getenv('GOOGLE_CLOUD_PROJECT')

# Retrieve secrets from Secret Manager
FIREBASE_CREDENTIALS_JSON = access_secret_version("firebase_credentials", PROJECT_ID)
GOOGLE_PLACES_API_KEY = access_secret_version("google_places_api_key", PROJECT_ID)

# Initialize Firebase Admin SDK
firebase_credentials = json.loads(FIREBASE_CREDENTIALS_JSON)
cred = credentials.Certificate(firebase_credentials)
firebase_admin.initialize_app(cred)

def get_nearby_offers(latitude, longitude, radius=1000):
    """
    Fetches nearby places using Google Places API.
    :param latitude: Latitude of the location
    :param longitude: Longitude of the location
    :param radius: Search radius in meters
    :return: List of place names and their types
    """
    url = 'https://maps.googleapis.com/maps/api/place/nearbysearch/json'
    params = {
        'location': f'{latitude},{longitude}',
        'radius': radius,
        'type': 'cafe|restaurant|store',  # Adjust types as needed
        'key': GOOGLE_PLACES_API_KEY
    }

    response = requests.get(url, params=params)
    if response.status_code != 200:
        logging.error(f"Google Places API error: {response.status_code}")
        return []

    results = response.json().get('results', [])
    offers = []
    for place in results[:5]:  # Limit to top 5 offers
        name = place.get('name')
        types = place.get('types', [])
        offers.append(f"{name} - {'/'.join(types)}")

    return offers

def format_offers(offers):
    """
    Formats the list of offers into a single string.
    :param offers: List of offer strings
    :return: Formatted offer summary
    """
    if not offers:
        return "No offers available at this time."

    offer_summary = "\n".join(offers)
    return offer_summary

@app.route('/start_charging', methods=['POST'])
def start_charging():
    """
    Endpoint to handle when a user starts charging.
    Expects JSON data with:
    - device_token (str): FCM device token of the user.
    - station_id (str): ID of the charging station.
    - latitude (float): Latitude of the charging station.
    - longitude (float): Longitude of the charging station.
    """
    data = request.get_json()

    device_token = data.get('device_token')
    station_id = data.get('station_id')
    latitude = data.get('latitude')
    longitude = data.get('longitude')

    logging.info(f"Received data: device_token={device_token}, station_id={station_id}, latitude={latitude}, longitude={longitude}")

    if not all([device_token, station_id, latitude, longitude]):
        logging.error("Missing required parameters.")
        return jsonify({'error': 'Missing required parameters.'}), 400

    # Fetch nearby offers
    offers = get_nearby_offers(latitude, longitude)
    offer_summary = format_offers(offers)

    # Prepare notification content
    title = "Exclusive Local Offers Just for You!"
    body = offer_summary

    # Create the message
    message = messaging.Message(
        notification=messaging.Notification(
            title=title,
            body=body
        ),
        token=device_token,
    )

    try:
        # Send the notification
        response = messaging.send(message)
        logging.info(f"Successfully sent message: {response}")
        return jsonify({'message': 'Notification sent successfully.'}), 200
    except Exception as e:
        logging.error(f"Error sending notification: {e}")
        return jsonify({'error': 'Failed to send notification.'}), 500

if __name__ == '__main__':
    # Run the Flask app
    app.run(host='0.0.0.0', port=int(os.getenv('PORT', 5000)), debug=True)